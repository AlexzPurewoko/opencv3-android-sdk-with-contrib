ok: class CLASS ::.Tracking : , name: Tracking, base: 

===== Common header : /Users/Chao/opencv/modules/dnn/misc/java/src/cpp/dnn_converters.hpp =====

===== Common header : /Users/Chao/opencv/modules/features2d/misc/java/src/cpp/features2d_converters.hpp =====


===== Header: /Users/Chao/opencv_contrib/modules/tracking/include/opencv2/tracking.hpp =====
Namespaces: set([])
Ignore header: /Users/Chao/opencv_contrib/modules/tracking/include/opencv2/tracking.hpp


===== Header: /Users/Chao/opencv_contrib/modules/tracking/include/opencv2/tracking/feature.hpp =====
Namespaces: set([u'cv'])

--- Incoming ---
[u'const cv.CvFeatureParams.HAAR', u'0', [], [], None, '']
class not found: CONST HAAR=0

--- Incoming ---
[u'const cv.CvFeatureParams.LBP', u'1', [], [], None, '']
class not found: CONST LBP=1

--- Incoming ---
[u'const cv.CvFeatureParams.HOG', u'2', [], [], None, '']
class not found: CONST HOG=2


===== Header: /Users/Chao/opencv_contrib/modules/tracking/include/opencv2/tracking/kalman_filters.hpp =====
Namespaces: set([u'cv.tracking', u'cv'])
Ignore header: /Users/Chao/opencv_contrib/modules/tracking/include/opencv2/tracking/kalman_filters.hpp


===== Header: /Users/Chao/opencv_contrib/modules/tracking/include/opencv2/tracking/onlineBoosting.hpp =====
Namespaces: set([u'cv.tracking', u'cv'])
Ignore header: /Users/Chao/opencv_contrib/modules/tracking/include/opencv2/tracking/onlineBoosting.hpp


===== Header: /Users/Chao/opencv_contrib/modules/tracking/include/opencv2/tracking/onlineMIL.hpp =====
Namespaces: set([u'cv.tracking', u'cv'])
Ignore header: /Users/Chao/opencv_contrib/modules/tracking/include/opencv2/tracking/onlineMIL.hpp


===== Header: /Users/Chao/opencv_contrib/modules/tracking/include/opencv2/tracking/tldDataset.hpp =====
Namespaces: set([u'cv.tracking', u'cv.tld', u'cv'])
Ignore header: /Users/Chao/opencv_contrib/modules/tracking/include/opencv2/tracking/tldDataset.hpp


===== Header: /Users/Chao/opencv_contrib/modules/tracking/include/opencv2/tracking/tracker.hpp =====
Namespaces: set([u'cv.tracking', u'cv.tld', u'cv'])

--- Incoming ---
[   u'class cv.Tracker',
    ': cv::Algorithm',
    [],
    [],
    None,
    u'@brief Base abstract class for the long-term tracker:']
ok: class CLASS cv::.Tracker : Algorithm, name: Tracker, base: Algorithm

--- Incoming ---
[   u'cv.Tracker.init',
    u'bool',
    [],
    [   ['Mat', u'image', '', []],
        [u'Rect2d', u'boundingBox', u'', ['/C', '/Ref']]],
    u'bool',
    u'@brief Initialize the tracker with a know bounding box that surrounding the target\n@param image The initial frame\n@param boundingBox The initial boundig box\n\n@return True if initialization went succesfully, false otherwise']
ok: FUNC <bool cv.Tracker.init [ARG Mat image=, ARG Rect2d boundingBox=]>

--- Incoming ---
[   u'cv.Tracker.update',
    u'bool',
    [],
    [   ['Mat', u'image', '', []],
        [u'Rect2d', u'boundingBox', u'', ['/O', '/Ref']]],
    u'bool',
    u'@brief Update the tracker, find the new most likely bounding box for the target\n@param image The current frame\n@param boundingBox The boundig box that represent the new target location, if true was returned, not\nmodified otherwise\n\n@return True means that target was located and false means that tracker cannot locate target in\ncurrent frame. Note, that latter *does not* imply that tracker has failed, maybe target is indeed\nmissing from the frame (say, out of sight)']
ok: FUNC <bool cv.Tracker.update [ARG Mat image=, ARG Rect2d boundingBox=]>

--- Incoming ---
[u'const cv.TrackerSamplerCSC.MODE_INIT_POS', u'1', [], [], None, '']
class not found: CONST MODE_INIT_POS=1

--- Incoming ---
[u'const cv.TrackerSamplerCSC.MODE_INIT_NEG', u'2', [], [], None, '']
class not found: CONST MODE_INIT_NEG=2

--- Incoming ---
[u'const cv.TrackerSamplerCSC.MODE_TRACK_POS', u'3', [], [], None, '']
class not found: CONST MODE_TRACK_POS=3

--- Incoming ---
[u'const cv.TrackerSamplerCSC.MODE_TRACK_NEG', u'4', [], [], None, '']
class not found: CONST MODE_TRACK_NEG=4

--- Incoming ---
[u'const cv.TrackerSamplerCSC.MODE_DETECT', u'5', [], [], None, '']
class not found: CONST MODE_DETECT=5

--- Incoming ---
[u'const cv.TrackerSamplerCS.MODE_POSITIVE', u'1', [], [], None, '']
class not found: CONST MODE_POSITIVE=1

--- Incoming ---
[u'const cv.TrackerSamplerCS.MODE_NEGATIVE', u'2', [], [], None, '']
class not found: CONST MODE_NEGATIVE=2

--- Incoming ---
[u'const cv.TrackerSamplerCS.MODE_CLASSIFY', u'3', [], [], None, '']
class not found: CONST MODE_CLASSIFY=3

--- Incoming ---
[   u'class cv.TrackerMIL',
    u': cv::Tracker',
    [],
    [],
    None,
    u'@brief The MIL algorithm trains a classifier in an online manner to separate the object from the\nbackground.\n\nMultiple Instance Learning avoids the drift problem for a robust tracking. The implementation is\nbased on @cite MIL .\n\nOriginal code can be found here <http://vision.ucsd.edu/~bbabenko/project_miltrack.shtml>']
ok: class CLASS cv::.TrackerMIL : Tracker, name: TrackerMIL, base: Tracker

--- Incoming ---
[   u'cv.TrackerMIL.create',
    u'Ptr_TrackerMIL',
    ['/S'],
    [],
    u'Ptr<TrackerMIL>',
    u'@brief Constructor\n@param parameters MIL parameters TrackerMIL::Params']
ok: FUNC <Ptr_TrackerMIL cv.TrackerMIL.create []>

--- Incoming ---
[   u'class cv.TrackerBoosting',
    u': cv::Tracker',
    [],
    [],
    None,
    u'@brief This is a real-time object tracking based on a novel on-line version of the AdaBoost algorithm.\n\nThe classifier uses the surrounding background as negative examples in update step to avoid the\ndrifting problem. The implementation is based on @cite OLB .']
ok: class CLASS cv::.TrackerBoosting : Tracker, name: TrackerBoosting, base: Tracker

--- Incoming ---
[   u'cv.TrackerBoosting.create',
    u'Ptr_TrackerBoosting',
    ['/S'],
    [],
    u'Ptr<TrackerBoosting>',
    u'@brief Constructor\n@param parameters BOOSTING parameters TrackerBoosting::Params']
ok: FUNC <Ptr_TrackerBoosting cv.TrackerBoosting.create []>

--- Incoming ---
[   u'class cv.TrackerMedianFlow',
    u': cv::Tracker',
    [],
    [],
    None,
    u"@brief Median Flow tracker implementation.\n\nImplementation of a paper @cite MedianFlow .\n\nThe tracker is suitable for very smooth and predictable movements when object is visible throughout\nthe whole sequence. It's quite and accurate for this type of problems (in particular, it was shown\nby authors to outperform MIL). During the implementation period the code at\n<http://www.aonsquared.co.uk/node/5>, the courtesy of the author Arthur Amarra, was used for the\nreference purpose."]
ok: class CLASS cv::.TrackerMedianFlow : Tracker, name: TrackerMedianFlow, base: Tracker

--- Incoming ---
[   u'cv.TrackerMedianFlow.create',
    u'Ptr_TrackerMedianFlow',
    ['/S'],
    [],
    u'Ptr<TrackerMedianFlow>',
    u'@brief Constructor\n@param parameters Median Flow parameters TrackerMedianFlow::Params']
ok: FUNC <Ptr_TrackerMedianFlow cv.TrackerMedianFlow.create []>

--- Incoming ---
[   u'class cv.TrackerTLD',
    u': cv::Tracker',
    [],
    [],
    None,
    u'@brief TLD is a novel tracking framework that explicitly decomposes the long-term tracking task into\ntracking, learning and detection.\n\nThe tracker follows the object from frame to frame. The detector localizes all appearances that\nhave been observed so far and corrects the tracker if necessary. The learning estimates detector\u2019s\nerrors and updates it to avoid these errors in the future. The implementation is based on @cite TLD .\n\nThe Median Flow algorithm (see cv::TrackerMedianFlow) was chosen as a tracking component in this\nimplementation, following authors. Tracker is supposed to be able to handle rapid motions, partial\nocclusions, object absence etc.']
ok: class CLASS cv::.TrackerTLD : Tracker, name: TrackerTLD, base: Tracker

--- Incoming ---
[   u'cv.TrackerTLD.create',
    u'Ptr_TrackerTLD',
    ['/S'],
    [],
    u'Ptr<TrackerTLD>',
    u'@brief Constructor\n@param parameters TLD parameters TrackerTLD::Params']
ok: FUNC <Ptr_TrackerTLD cv.TrackerTLD.create []>

--- Incoming ---
[   u'class cv.TrackerKCF',
    u': cv::Tracker',
    [],
    [],
    None,
    u'@brief KCF is a novel tracking framework that utilizes properties of circulant matrix to enhance the processing speed.\n* This tracking method is an implementation of @cite KCF_ECCV which is extended to KFC with color-names features (@cite KCF_CN).\n* The original paper of KCF is available at <http://www.robots.ox.ac.uk/~joao/publications/henriques_tpami2015.pdf>\n* as well as the matlab implementation. For more information about KCF with color-names features, please refer to\n* <http://www.cvl.isy.liu.se/research/objrec/visualtracking/colvistrack/index.html>.']
ok: class CLASS cv::.TrackerKCF : Tracker, name: TrackerKCF, base: Tracker

--- Incoming ---
[u'const cv.TrackerKCF.GRAY', u'(1 << 0)', [], [], None, '']
ok: CONST GRAY=(1 << 0)

--- Incoming ---
[u'const cv.TrackerKCF.CN', u'(1 << 1)', [], [], None, '']
ok: CONST CN=(1 << 1)

--- Incoming ---
[u'const cv.TrackerKCF.CUSTOM', u'(1 << 2)', [], [], None, '']
ok: CONST CUSTOM=(1 << 2)

--- Incoming ---
[   u'cv.TrackerKCF.create',
    u'Ptr_TrackerKCF',
    ['/S'],
    [],
    u'Ptr<TrackerKCF>',
    u'@brief Constructor\n@param parameters KCF parameters TrackerKCF::Params']
ok: FUNC <Ptr_TrackerKCF cv.TrackerKCF.create []>

--- Incoming ---
[   u'class cv.TrackerGOTURN',
    u': cv::Tracker',
    [],
    [],
    None,
    u'@brief GOTURN (@cite GOTURN) is kind of trackers based on Convolutional Neural Networks (CNN). While taking all advantages of CNN trackers,\n*  GOTURN is much faster due to offline training without online fine-tuning nature.\n*  GOTURN tracker addresses the problem of single target tracking: given a bounding box label of an object in the first frame of the video,\n*  we track that object through the rest of the video. NOTE: Current method of GOTURN does not handle occlusions; however, it is fairly\n*  robust to viewpoint changes, lighting changes, and deformations.\n*  Inputs of GOTURN are two RGB patches representing Target and Search patches resized to 227x227.\n*  Outputs of GOTURN are predicted bounding box coordinates, relative to Search patch coordinate system, in format X1,Y1,X2,Y2.\n*  Original paper is here: <http://davheld.github.io/GOTURN/GOTURN.pdf>\n*  As long as original authors implementation: <https://github.com/davheld/GOTURN#train-the-tracker>\n*  Implementation of training algorithm is placed in separately here due to 3d-party dependencies:\n*  <https://github.com/Auron-X/GOTURN_Training_Toolkit>\n*  GOTURN architecture goturn.prototxt and trained model goturn.caffemodel are accessible on opencv_extra GitHub repository.']
ok: class CLASS cv::.TrackerGOTURN : Tracker, name: TrackerGOTURN, base: Tracker

--- Incoming ---
[   u'cv.TrackerGOTURN.create',
    u'Ptr_TrackerGOTURN',
    ['/S'],
    [],
    u'Ptr<TrackerGOTURN>',
    u'@brief Constructor\n@param parameters GOTURN parameters TrackerGOTURN::Params']
ok: FUNC <Ptr_TrackerGOTURN cv.TrackerGOTURN.create []>

--- Incoming ---
[   u'class cv.TrackerMOSSE',
    u': cv::Tracker',
    [],
    [],
    None,
    u'@brief the MOSSE tracker\nnote, that this tracker works with grayscale images, if passed bgr ones, they will get converted internally.\n@cite MOSSE Visual Object Tracking using Adaptive Correlation Filters']
ok: class CLASS cv::.TrackerMOSSE : Tracker, name: TrackerMOSSE, base: Tracker

--- Incoming ---
[   u'cv.TrackerMOSSE.create',
    u'Ptr_TrackerMOSSE',
    ['/S'],
    [],
    u'Ptr<TrackerMOSSE>',
    u'@brief Constructor']
ok: FUNC <Ptr_TrackerMOSSE cv.TrackerMOSSE.create []>

--- Incoming ---
[   u'class cv.MultiTracker',
    ': cv::Algorithm',
    [],
    [],
    None,
    u'@brief This class is used to track multiple objects using the specified tracker algorithm.\n* The MultiTracker is naive implementation of multiple object tracking.\n* It process the tracked objects independently without any optimization accross the tracked objects.']
ok: class CLASS cv::.MultiTracker : Algorithm, name: MultiTracker, base: Algorithm

--- Incoming ---
[u'cv.MultiTracker.MultiTracker', '', [], [], None, u'* \\brief Constructor.']
ok: FUNC < cv.MultiTracker.MultiTracker []>

--- Incoming ---
[   u'cv.MultiTracker.add',
    u'bool',
    [],
    [   [u'Ptr_Tracker', u'newTracker', u'', []],
        ['Mat', u'image', '', []],
        [u'Rect2d', u'boundingBox', u'', ['/C', '/Ref']]],
    u'bool',
    u'* \\brief Add a new object to be tracked.\n*\n* @param newTracker tracking algorithm to be used\n* @param image input image\n* @param boundingBox a rectangle represents ROI of the tracked object']
ok: FUNC <bool cv.MultiTracker.add [ARG Ptr_Tracker newTracker=, ARG Mat image=, ARG Rect2d boundingBox=]>

--- Incoming ---
[   u'cv.MultiTracker.update',
    u'bool',
    [],
    [   ['Mat', u'image', '', []],
        [u'vector_Rect2d', u'boundingBox', u'', ['/O', '/Ref']]],
    u'bool',
    u'* \\brief Update the current tracking status.\n* @param image input image\n* @param boundingBox the tracking result, represent a list of ROIs of the tracked objects.']
ok: FUNC <bool cv.MultiTracker.update [ARG Mat image=, ARG vector_Rect2d boundingBox=]>

--- Incoming ---
[   u'cv.MultiTracker.getObjects',
    u'vector_Rect2d',
    ['/C'],
    [],
    u'std::vector<Rect2d>',
    u'* \\brief Returns a reference to a storage for the tracked objects, each object corresponds to one tracker algorithm']
ok: FUNC <vector_Rect2d cv.MultiTracker.getObjects []>

--- Incoming ---
[   u'cv.MultiTracker.create',
    u'Ptr_MultiTracker',
    ['/S'],
    [],
    u'Ptr<MultiTracker>',
    u'* \\brief Returns a pointer to a new instance of MultiTracker']
ok: FUNC <Ptr_MultiTracker cv.MultiTracker.create []>


===== Header: /Users/Chao/opencv_contrib/modules/tracking/include/opencv2/tracking/tracking.hpp =====
Namespaces: set([u'cv.tracking', u'cv.tld', u'cv'])
Ignore header: /Users/Chao/opencv_contrib/modules/tracking/include/opencv2/tracking/tracking.hpp


===== Generating... =====
CLASS ::.Tracking : 
CLASS cv::.Tracker : Algorithm
FUNC <bool cv.Tracker.init [ARG Mat image=, ARG Rect2d boundingBox=]>
java: boolean init(Mat image, Rect2d boundingBox)
FUNC <bool cv.Tracker.update [ARG Mat image=, ARG Rect2d boundingBox=]>
java: boolean update(Mat image, Rect2d boundingBox)
CLASS cv::.TrackerMIL : Tracker
FUNC <Ptr_TrackerMIL cv.TrackerMIL.create []>
java: TrackerMIL create()
CLASS cv::.TrackerGOTURN : Tracker
FUNC <Ptr_TrackerGOTURN cv.TrackerGOTURN.create []>
java: TrackerGOTURN create()
CLASS cv::.TrackerTLD : Tracker
FUNC <Ptr_TrackerTLD cv.TrackerTLD.create []>
java: TrackerTLD create()
CLASS cv::.TrackerMedianFlow : Tracker
FUNC <Ptr_TrackerMedianFlow cv.TrackerMedianFlow.create []>
java: TrackerMedianFlow create()
CLASS cv::.TrackerBoosting : Tracker
FUNC <Ptr_TrackerBoosting cv.TrackerBoosting.create []>
java: TrackerBoosting create()
CLASS cv::.MultiTracker : Algorithm
FUNC < cv.MultiTracker.MultiTracker []>
java:  MultiTracker()
FUNC <Ptr_MultiTracker cv.MultiTracker.create []>
java: MultiTracker create()
FUNC <bool cv.MultiTracker.add [ARG Ptr_Tracker newTracker=, ARG Mat image=, ARG Rect2d boundingBox=]>
java: boolean add(Tracker newTracker, Mat image, Rect2d boundingBox)
FUNC <bool cv.MultiTracker.update [ARG Mat image=, ARG vector_Rect2d boundingBox=]>
java: boolean update(Mat image, MatOfRect2d boundingBox)
FUNC <vector_Rect2d cv.MultiTracker.getObjects []>
java: MatOfRect2d getObjects()
CLASS cv::.TrackerMOSSE : Tracker
FUNC <Ptr_TrackerMOSSE cv.TrackerMOSSE.create []>
java: TrackerMOSSE create()
CLASS cv::.TrackerKCF : Tracker
[CONST GRAY=(1 << 0), CONST CN=(1 << 1), CONST CUSTOM=(1 << 2)]
FUNC <Ptr_TrackerKCF cv.TrackerKCF.create []>
java: TrackerKCF create()
