ok: class CLASS ::.Aruco : , name: Aruco, base: 

===== Common header : /Users/Chao/opencv/modules/features2d/misc/java/src/cpp/features2d_converters.hpp =====


===== Header: /Users/Chao/opencv_contrib/modules/aruco/include/opencv2/aruco.hpp =====
Namespaces: set([u'cv.aruco', u'cv'])

--- Incoming ---
[u'const cv.aruco.CORNER_REFINE_NONE', '0', [], [], None, '']
ok: CONST CORNER_REFINE_NONE=0

--- Incoming ---
[u'const cv.aruco.CORNER_REFINE_SUBPIX', '1', [], [], None, '']
ok: CONST CORNER_REFINE_SUBPIX=1

--- Incoming ---
[u'const cv.aruco.CORNER_REFINE_CONTOUR', '2', [], [], None, '']
ok: CONST CORNER_REFINE_CONTOUR=2

--- Incoming ---
[   u'struct cv.aruco.DetectorParameters',
    '',
    [],
    [   [u'int', u'adaptiveThreshWinSizeMin', '', ['/RW']],
        [u'int', u'adaptiveThreshWinSizeMax', '', ['/RW']],
        [u'int', u'adaptiveThreshWinSizeStep', '', ['/RW']],
        [u'double', u'adaptiveThreshConstant', '', ['/RW']],
        [u'double', u'minMarkerPerimeterRate', '', ['/RW']],
        [u'double', u'maxMarkerPerimeterRate', '', ['/RW']],
        [u'double', u'polygonalApproxAccuracyRate', '', ['/RW']],
        [u'double', u'minCornerDistanceRate', '', ['/RW']],
        [u'int', u'minDistanceToBorder', '', ['/RW']],
        [u'double', u'minMarkerDistanceRate', '', ['/RW']],
        [u'int', u'cornerRefinementMethod', '', ['/RW']],
        [u'int', u'cornerRefinementWinSize', '', ['/RW']],
        [u'int', u'cornerRefinementMaxIterations', '', ['/RW']],
        [u'double', u'cornerRefinementMinAccuracy', '', ['/RW']],
        [u'int', u'markerBorderBits', '', ['/RW']],
        [u'int', u'perspectiveRemovePixelPerCell', '', ['/RW']],
        [u'double', u'perspectiveRemoveIgnoredMarginPerCell', '', ['/RW']],
        [u'double', u'maxErroneousBitsInBorderRate', '', ['/RW']],
        [u'double', u'minOtsuStdDev', '', ['/RW']],
        [u'double', u'errorCorrectionRate', '', ['/RW']]],
    None,
    u'* @brief Parameters for the detectMarker process:\n* - adaptiveThreshWinSizeMin: minimum window size for adaptive thresholding before finding\n*   contours (default 3).\n* - adaptiveThreshWinSizeMax: maximum window size for adaptive thresholding before finding\n*   contours (default 23).\n* - adaptiveThreshWinSizeStep: increments from adaptiveThreshWinSizeMin to adaptiveThreshWinSizeMax\n*   during the thresholding (default 10).\n* - adaptiveThreshConstant: constant for adaptive thresholding before finding contours (default 7)\n* - minMarkerPerimeterRate: determine minimum perimeter for marker contour to be detected. This\n*   is defined as a rate respect to the maximum dimension of the input image (default 0.03).\n* - maxMarkerPerimeterRate:  determine maximum perimeter for marker contour to be detected. This\n*   is defined as a rate respect to the maximum dimension of the input image (default 4.0).\n* - polygonalApproxAccuracyRate: minimum accuracy during the polygonal approximation process to\n*   determine which contours are squares.\n* - minCornerDistanceRate: minimum distance between corners for detected markers relative to its\n*   perimeter (default 0.05)\n* - minDistanceToBorder: minimum distance of any corner to the image border for detected markers\n*   (in pixels) (default 3)\n* - minMarkerDistanceRate: minimum mean distance beetween two marker corners to be considered\n*   similar, so that the smaller one is removed. The rate is relative to the smaller perimeter\n*   of the two markers (default 0.05).\n* - cornerRefinementMethod: corner refinement method. (CORNER_REFINE_NONE, no refinement.\n*   CORNER_REFINE_SUBPIX, do subpixel refinement. CORNER_REFINE_CONTOUR use contour-Points)\n* - cornerRefinementWinSize: window size for the corner refinement process (in pixels) (default 5).\n* - cornerRefinementMaxIterations: maximum number of iterations for stop criteria of the corner\n*   refinement process (default 30).\n* - cornerRefinementMinAccuracy: minimum error for the stop cristeria of the corner refinement\n*   process (default: 0.1)\n* - markerBorderBits: number of bits of the marker border, i.e. marker border width (default 1).\n* - perpectiveRemovePixelPerCell: number of bits (per dimension) for each cell of the marker\n*   when removing the perspective (default 8).\n* - perspectiveRemoveIgnoredMarginPerCell: width of the margin of pixels on each cell not\n*   considered for the determination of the cell bit. Represents the rate respect to the total\n*   size of the cell, i.e. perpectiveRemovePixelPerCell (default 0.13)\n* - maxErroneousBitsInBorderRate: maximum number of accepted erroneous bits in the border (i.e.\n*   number of allowed white bits in the border). Represented as a rate respect to the total\n*   number of bits per marker (default 0.35).\n* - minOtsuStdDev: minimun standard deviation in pixels values during the decodification step to\n*   apply Otsu thresholding (otherwise, all the bits are set to 0 or 1 depending on mean higher\n*   than 128 or not) (default 5.0)\n* - errorCorrectionRate error correction rate respect to the maximun error correction capability\n*   for each dictionary. (default 0.6).']
ok: class CLASS cv.aruco::.DetectorParameters : , name: DetectorParameters, base: 

--- Incoming ---
[   u'cv.aruco.DetectorParameters.create',
    u'Ptr_DetectorParameters',
    ['/S'],
    [],
    u'Ptr<DetectorParameters>',
    '']
ok: FUNC <Ptr_DetectorParameters cv.aruco.DetectorParameters.create []>

--- Incoming ---
[   u'cv.aruco.detectMarkers',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        [u'Ptr_Dictionary', u'dictionary', u'', ['/C', '/Ref']],
        ['vector_Mat', u'corners', '', ['/O']],
        ['Mat', u'ids', '', ['/O']],
        [   u'Ptr_DetectorParameters',
            u'parameters',
            u'DetectorParameters::create()',
            ['/C', '/Ref']],
        ['vector_Mat', u'rejectedImgPoints', u'vector_Mat()', ['/O']],
        ['Mat', u'cameraMatrix', u'Mat()', []],
        ['Mat', u'distCoeff', u'Mat()', []]],
    u'void',
    u'* @brief Basic marker detection\n*\n* @param image input image\n* @param dictionary indicates the type of markers that will be searched\n* @param corners vector of detected marker corners. For each marker, its four corners\n* are provided, (e.g std::vector<std::vector<cv::Point2f> > ). For N detected markers,\n* the dimensions of this array is Nx4. The order of the corners is clockwise.\n* @param ids vector of identifiers of the detected markers. The identifier is of type int\n* (e.g. std::vector<int>). For N detected markers, the size of ids is also N.\n* The identifiers have the same order than the markers in the imgPoints array.\n* @param parameters marker detection parameters\n* @param rejectedImgPoints contains the imgPoints of those squares whose inner code has not a\n* correct codification. Useful for debugging purposes.\n* @param cameraMatrix optional input 3x3 floating-point camera matrix\n* \\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$\n* @param distCoeff optional vector of distortion coefficients\n* \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6],[s_1, s_2, s_3, s_4]])\\f$ of 4, 5, 8 or 12 elements\n*\n* Performs marker detection in the input image. Only markers included in the specific dictionary\n* are searched. For each detected marker, it returns the 2D position of its corner in the image\n* and its corresponding identifier.\n* Note that this function does not perform pose estimation.\n* @sa estimatePoseSingleMarkers,  estimatePoseBoard\n*']
ok: FUNC <void cv.aruco..detectMarkers [ARG Mat image=, ARG Ptr_Dictionary dictionary=, ARG vector_Mat corners=, ARG Mat ids=, ARG Ptr_DetectorParameters parameters=DetectorParameters::create(), ARG vector_Mat rejectedImgPoints=vector_Mat(), ARG Mat cameraMatrix=Mat(), ARG Mat distCoeff=Mat()]>

--- Incoming ---
[   u'cv.aruco.estimatePoseSingleMarkers',
    u'void',
    [],
    [   ['vector_Mat', u'corners', '', []],
        [u'float', u'markerLength', u'', []],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'rvecs', '', ['/O']],
        ['Mat', u'tvecs', '', ['/O']],
        ['Mat', u'_objPoints', u'Mat()', ['/O']]],
    u'void',
    u"* @brief Pose estimation for single markers\n*\n* @param corners vector of already detected markers corners. For each marker, its four corners\n* are provided, (e.g std::vector<std::vector<cv::Point2f> > ). For N detected markers,\n* the dimensions of this array should be Nx4. The order of the corners should be clockwise.\n* @sa detectMarkers\n* @param markerLength the length of the markers' side. The returning translation vectors will\n* be in the same unit. Normally, unit is meters.\n* @param cameraMatrix input 3x3 floating-point camera matrix\n* \\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$\n* @param distCoeffs vector of distortion coefficients\n* \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6],[s_1, s_2, s_3, s_4]])\\f$ of 4, 5, 8 or 12 elements\n* @param rvecs array of output rotation vectors (@sa Rodrigues) (e.g. std::vector<cv::Vec3d>).\n* Each element in rvecs corresponds to the specific marker in imgPoints.\n* @param tvecs array of output translation vectors (e.g. std::vector<cv::Vec3d>).\n* Each element in tvecs corresponds to the specific marker in imgPoints.\n* @param _objPoints array of object points of all the marker corners\n*\n* This function receives the detected markers and returns their pose estimation respect to\n* the camera individually. So for each marker, one rotation and translation vector is returned.\n* The returned transformation is the one that transforms points from each marker coordinate system\n* to the camera coordinate system.\n* The marker corrdinate system is centered on the middle of the marker, with the Z axis\n* perpendicular to the marker plane.\n* The coordinates of the four corners of the marker in its own coordinate system are:\n* (-markerLength/2, markerLength/2, 0), (markerLength/2, markerLength/2, 0),\n* (markerLength/2, -markerLength/2, 0), (-markerLength/2, -markerLength/2, 0)"]
ok: FUNC <void cv.aruco..estimatePoseSingleMarkers [ARG vector_Mat corners=, ARG float markerLength=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvecs=, ARG Mat tvecs=, ARG Mat _objPoints=Mat()]>

--- Incoming ---
[   u'class cv.aruco.Board',
    '',
    [],
    [   [u'vector_vector_Point3f', u'objPoints', '', []],
        [u'Ptr_Dictionary', u'dictionary', '', []],
        [u'vector_int', u'ids', '', []]],
    None,
    u'* @brief Board of markers\n*\n* A board is a set of markers in the 3D space with a common cordinate system.\n* The common form of a board of marker is a planar (2D) board, however any 3D layout can be used.\n* A Board object is composed by:\n* - The object points of the marker corners, i.e. their coordinates respect to the board system.\n* - The dictionary which indicates the type of markers of the board\n* - The identifier of all the markers in the board.']
ok: class CLASS cv.aruco::.Board : , name: Board, base: 

--- Incoming ---
[   u'cv.aruco.Board.create',
    u'Ptr_Board',
    ['/S'],
    [   ['vector_Mat', u'objPoints', '', []],
        [u'Ptr_Dictionary', u'dictionary', u'', ['/C', '/Ref']],
        ['Mat', u'ids', '', []]],
    u'Ptr<Board>',
    u'* @brief Provide way to create Board by passing nessesary data. Specially needed in Python.\n*\n* @param objPoints array of object points of all the marker corners in the board\n* @param dictionary the dictionary of markers employed for this board\n* @param ids vector of the identifiers of the markers in the board\n*']
ok: FUNC <Ptr_Board cv.aruco.Board.create [ARG vector_Mat objPoints=, ARG Ptr_Dictionary dictionary=, ARG Mat ids=]>

--- Incoming ---
[   u'class cv.aruco.GridBoard',
    u': cv::aruco::Board',
    [],
    [],
    None,
    u'* @brief Planar board with grid arrangement of markers\n* More common type of board. All markers are placed in the same plane in a grid arrangment.\n* The board can be drawn using drawPlanarBoard() function (@sa drawPlanarBoard)']
ok: class CLASS cv.aruco::.GridBoard : Board, name: GridBoard, base: Board

--- Incoming ---
[   u'cv.aruco.GridBoard.draw',
    u'void',
    [],
    [   [u'Size', u'outSize', u'', []],
        ['Mat', u'img', '', ['/O']],
        [u'int', u'marginSize', u'0', []],
        [u'int', u'borderBits', u'1', []]],
    u'void',
    u'* @brief Draw a GridBoard\n*\n* @param outSize size of the output image in pixels.\n* @param img output image with the board. The size of this image will be outSize\n* and the board will be on the center, keeping the board proportions.\n* @param marginSize minimum margins (in pixels) of the board in the output image\n* @param borderBits width of the marker borders.\n*\n* This function return the image of the GridBoard, ready to be printed.']
ok: FUNC <void cv.aruco.GridBoard.draw [ARG Size outSize=, ARG Mat img=, ARG int marginSize=0, ARG int borderBits=1]>

--- Incoming ---
[   u'cv.aruco.GridBoard.create',
    u'Ptr_GridBoard',
    ['/S'],
    [   [u'int', u'markersX', u'', []],
        [u'int', u'markersY', u'', []],
        [u'float', u'markerLength', u'', []],
        [u'float', u'markerSeparation', u'', []],
        [u'Ptr_Dictionary', u'dictionary', u'', ['/C', '/Ref']],
        [u'int', u'firstMarker', u'0', []]],
    u'Ptr<GridBoard>',
    u'* @brief Create a GridBoard object\n*\n* @param markersX number of markers in X direction\n* @param markersY number of markers in Y direction\n* @param markerLength marker side length (normally in meters)\n* @param markerSeparation separation between two markers (same unit as markerLength)\n* @param dictionary dictionary of markers indicating the type of markers\n* @param firstMarker id of first marker in dictionary to use on board.\n* @return the output GridBoard object\n*\n* This functions creates a GridBoard object given the number of markers in each direction and\n* the marker size and marker separation.']
ok: FUNC <Ptr_GridBoard cv.aruco.GridBoard.create [ARG int markersX=, ARG int markersY=, ARG float markerLength=, ARG float markerSeparation=, ARG Ptr_Dictionary dictionary=, ARG int firstMarker=0]>

--- Incoming ---
[u'cv.aruco.GridBoard.getGridSize', u'Size', ['/C'], [], u'Size', u'*']
ok: FUNC <Size cv.aruco.GridBoard.getGridSize []>

--- Incoming ---
[u'cv.aruco.GridBoard.getMarkerLength', u'float', ['/C'], [], u'float', u'*']
ok: FUNC <float cv.aruco.GridBoard.getMarkerLength []>

--- Incoming ---
[   u'cv.aruco.GridBoard.getMarkerSeparation',
    u'float',
    ['/C'],
    [],
    u'float',
    u'*']
ok: FUNC <float cv.aruco.GridBoard.getMarkerSeparation []>

--- Incoming ---
[   u'cv.aruco.estimatePoseBoard',
    u'int',
    [],
    [   ['vector_Mat', u'corners', '', []],
        ['Mat', u'ids', '', []],
        [u'Ptr_Board', u'board', u'', ['/C', '/Ref']],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'rvec', '', ['/O']],
        ['Mat', u'tvec', '', ['/O']],
        [u'bool', u'useExtrinsicGuess', u'false', []]],
    u'int',
    u'* @brief Pose estimation for a board of markers\n*\n* @param corners vector of already detected markers corners. For each marker, its four corners\n* are provided, (e.g std::vector<std::vector<cv::Point2f> > ). For N detected markers, the\n* dimensions of this array should be Nx4. The order of the corners should be clockwise.\n* @param ids list of identifiers for each marker in corners\n* @param board layout of markers in the board. The layout is composed by the marker identifiers\n* and the positions of each marker corner in the board reference system.\n* @param cameraMatrix input 3x3 floating-point camera matrix\n* \\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$\n* @param distCoeffs vector of distortion coefficients\n* \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6],[s_1, s_2, s_3, s_4]])\\f$ of 4, 5, 8 or 12 elements\n* @param rvec Output vector (e.g. cv::Mat) corresponding to the rotation vector of the board\n* (see cv::Rodrigues). Used as initial guess if not empty.\n* @param tvec Output vector (e.g. cv::Mat) corresponding to the translation vector of the board.\n* @param useExtrinsicGuess defines whether initial guess for \\b rvec and \\b tvec will be used or not.\n* Used as initial guess if not empty.\n*\n* This function receives the detected markers and returns the pose of a marker board composed\n* by those markers.\n* A Board of marker has a single world coordinate system which is defined by the board layout.\n* The returned transformation is the one that transforms points from the board coordinate system\n* to the camera coordinate system.\n* Input markers that are not included in the board layout are ignored.\n* The function returns the number of markers from the input employed for the board pose estimation.\n* Note that returning a 0 means the pose has not been estimated.']
ok: FUNC <int cv.aruco..estimatePoseBoard [ARG vector_Mat corners=, ARG Mat ids=, ARG Ptr_Board board=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false]>

--- Incoming ---
[   u'cv.aruco.refineDetectedMarkers',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        [u'Ptr_Board', u'board', u'', ['/C', '/Ref']],
        ['vector_Mat', u'detectedCorners', '', ['/IO']],
        ['Mat', u'detectedIds', '', ['/IO']],
        ['vector_Mat', u'rejectedCorners', '', ['/IO']],
        ['Mat', u'cameraMatrix', u'Mat()', []],
        ['Mat', u'distCoeffs', u'Mat()', []],
        [u'float', u'minRepDistance', u'10.f', []],
        [u'float', u'errorCorrectionRate', u'3.f', []],
        [u'bool', u'checkAllOrders', u'true', []],
        ['Mat', u'recoveredIdxs', u'Mat()', ['/O']],
        [   u'Ptr_DetectorParameters',
            u'parameters',
            u'DetectorParameters::create()',
            ['/C', '/Ref']]],
    u'void',
    u'* @brief Refind not detected markers based on the already detected and the board layout\n*\n* @param image input image\n* @param board layout of markers in the board.\n* @param detectedCorners vector of already detected marker corners.\n* @param detectedIds vector of already detected marker identifiers.\n* @param rejectedCorners vector of rejected candidates during the marker detection process.\n* @param cameraMatrix optional input 3x3 floating-point camera matrix\n* \\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$\n* @param distCoeffs optional vector of distortion coefficients\n* \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6],[s_1, s_2, s_3, s_4]])\\f$ of 4, 5, 8 or 12 elements\n* @param minRepDistance minimum distance between the corners of the rejected candidate and the\n* reprojected marker in order to consider it as a correspondence.\n* @param errorCorrectionRate rate of allowed erroneous bits respect to the error correction\n* capability of the used dictionary. -1 ignores the error correction step.\n* @param checkAllOrders Consider the four posible corner orders in the rejectedCorners array.\n* If it set to false, only the provided corner order is considered (default true).\n* @param recoveredIdxs Optional array to returns the indexes of the recovered candidates in the\n* original rejectedCorners array.\n* @param parameters marker detection parameters\n*\n* This function tries to find markers that were not detected in the basic detecMarkers function.\n* First, based on the current detected marker and the board layout, the function interpolates\n* the position of the missing markers. Then it tries to find correspondence between the reprojected\n* markers and the rejected candidates based on the minRepDistance and errorCorrectionRate\n* parameters.\n* If camera parameters and distortion coefficients are provided, missing markers are reprojected\n* using projectPoint function. If not, missing marker projections are interpolated using global\n* homography, and all the marker corners in the board must have the same Z coordinate.']
ok: FUNC <void cv.aruco..refineDetectedMarkers [ARG Mat image=, ARG Ptr_Board board=, ARG vector_Mat detectedCorners=, ARG Mat detectedIds=, ARG vector_Mat rejectedCorners=, ARG Mat cameraMatrix=Mat(), ARG Mat distCoeffs=Mat(), ARG float minRepDistance=10.f, ARG float errorCorrectionRate=3.f, ARG bool checkAllOrders=true, ARG Mat recoveredIdxs=Mat(), ARG Ptr_DetectorParameters parameters=DetectorParameters::create()]>

--- Incoming ---
[   u'cv.aruco.drawDetectedMarkers',
    u'void',
    [],
    [   ['Mat', u'image', '', ['/IO']],
        ['vector_Mat', u'corners', '', []],
        ['Mat', u'ids', u'Mat()', []],
        [u'Scalar', u'borderColor', u'Scalar(0, 255, 0)', []]],
    u'void',
    u'* @brief Draw detected markers in image\n*\n* @param image input/output image. It must have 1 or 3 channels. The number of channels is not\n* altered.\n* @param corners positions of marker corners on input image.\n* (e.g std::vector<std::vector<cv::Point2f> > ). For N detected markers, the dimensions of\n* this array should be Nx4. The order of the corners should be clockwise.\n* @param ids vector of identifiers for markers in markersCorners .\n* Optional, if not provided, ids are not painted.\n* @param borderColor color of marker borders. Rest of colors (text color and first corner color)\n* are calculated based on this one to improve visualization.\n*\n* Given an array of detected marker corners and its corresponding ids, this functions draws\n* the markers in the image. The marker borders are painted and the markers identifiers if provided.\n* Useful for debugging purposes.']
ok: FUNC <void cv.aruco..drawDetectedMarkers [ARG Mat image=, ARG vector_Mat corners=, ARG Mat ids=Mat(), ARG Scalar borderColor=Scalar(0, 255, 0)]>

--- Incoming ---
[   u'cv.aruco.drawAxis',
    u'void',
    [],
    [   ['Mat', u'image', '', ['/IO']],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'rvec', '', []],
        ['Mat', u'tvec', '', []],
        [u'float', u'length', u'', []]],
    u'void',
    u'* @brief Draw coordinate system axis from pose estimation\n*\n* @param image input/output image. It must have 1 or 3 channels. The number of channels is not\n* altered.\n* @param cameraMatrix input 3x3 floating-point camera matrix\n* \\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$\n* @param distCoeffs vector of distortion coefficients\n* \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6],[s_1, s_2, s_3, s_4]])\\f$ of 4, 5, 8 or 12 elements\n* @param rvec rotation vector of the coordinate system that will be drawn. (@sa Rodrigues).\n* @param tvec translation vector of the coordinate system that will be drawn.\n* @param length length of the painted axis in the same unit than tvec (usually in meters)\n*\n* Given the pose estimation of a marker or board, this function draws the axis of the world\n* coordinate system, i.e. the system centered on the marker/board. Useful for debugging purposes.']
ok: FUNC <void cv.aruco..drawAxis [ARG Mat image=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG float length=]>

--- Incoming ---
[   u'cv.aruco.drawMarker',
    u'void',
    [],
    [   [u'Ptr_Dictionary', u'dictionary', u'', ['/C', '/Ref']],
        [u'int', u'id', u'', []],
        [u'int', u'sidePixels', u'', []],
        ['Mat', u'img', '', ['/O']],
        [u'int', u'borderBits', u'1', []]],
    u'void',
    u'* @brief Draw a canonical marker image\n*\n* @param dictionary dictionary of markers indicating the type of markers\n* @param id identifier of the marker that will be returned. It has to be a valid id\n* in the specified dictionary.\n* @param sidePixels size of the image in pixels\n* @param img output image with the marker\n* @param borderBits width of the marker border.\n*\n* This function returns a marker image in its canonical form (i.e. ready to be printed)']
ok: FUNC <void cv.aruco..drawMarker [ARG Ptr_Dictionary dictionary=, ARG int id=, ARG int sidePixels=, ARG Mat img=, ARG int borderBits=1]>

--- Incoming ---
[   u'cv.aruco.drawPlanarBoard',
    u'void',
    [],
    [   [u'Ptr_Board', u'board', u'', ['/C', '/Ref']],
        [u'Size', u'outSize', u'', []],
        ['Mat', u'img', '', ['/O']],
        [u'int', u'marginSize', u'0', []],
        [u'int', u'borderBits', u'1', []]],
    u'void',
    u'* @brief Draw a planar board\n* @sa _drawPlanarBoardImpl\n*\n* @param board layout of the board that will be drawn. The board should be planar,\n* z coordinate is ignored\n* @param outSize size of the output image in pixels.\n* @param img output image with the board. The size of this image will be outSize\n* and the board will be on the center, keeping the board proportions.\n* @param marginSize minimum margins (in pixels) of the board in the output image\n* @param borderBits width of the marker borders.\n*\n* This function return the image of a planar board, ready to be printed. It assumes\n* the Board layout specified is planar by ignoring the z coordinates of the object points.']
ok: FUNC <void cv.aruco..drawPlanarBoard [ARG Ptr_Board board=, ARG Size outSize=, ARG Mat img=, ARG int marginSize=0, ARG int borderBits=1]>

--- Incoming ---
[   u'cv.aruco.calibrateCameraAruco',
    u'double',
    [u'=calibrateCameraArucoExtended'],
    [   ['vector_Mat', u'corners', '', []],
        ['Mat', u'ids', '', []],
        ['Mat', u'counter', '', []],
        [u'Ptr_Board', u'board', u'', ['/C', '/Ref']],
        [u'Size', u'imageSize', u'', []],
        ['Mat', u'cameraMatrix', '', ['/IO']],
        ['Mat', u'distCoeffs', '', ['/IO']],
        ['vector_Mat', u'rvecs', '', ['/O']],
        ['vector_Mat', u'tvecs', '', ['/O']],
        ['Mat', u'stdDeviationsIntrinsics', '', ['/O']],
        ['Mat', u'stdDeviationsExtrinsics', '', ['/O']],
        ['Mat', u'perViewErrors', '', ['/O']],
        [u'int', u'flags', u'0', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)',
            []]],
    u'double',
    u"* @brief Calibrate a camera using aruco markers\n*\n* @param corners vector of detected marker corners in all frames.\n* The corners should have the same format returned by detectMarkers (see #detectMarkers).\n* @param ids list of identifiers for each marker in corners\n* @param counter number of markers in each frame so that corners and ids can be split\n* @param board Marker Board layout\n* @param imageSize Size of the image used only to initialize the intrinsic camera matrix.\n* @param cameraMatrix Output 3x3 floating-point camera matrix\n* \\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ . If CV\\_CALIB\\_USE\\_INTRINSIC\\_GUESS\n* and/or CV_CALIB_FIX_ASPECT_RATIO are specified, some or all of fx, fy, cx, cy must be\n* initialized before calling the function.\n* @param distCoeffs Output vector of distortion coefficients\n* \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6],[s_1, s_2, s_3, s_4]])\\f$ of 4, 5, 8 or 12 elements\n* @param rvecs Output vector of rotation vectors (see Rodrigues ) estimated for each board view\n* (e.g. std::vector<cv::Mat>>). That is, each k-th rotation vector together with the corresponding\n* k-th translation vector (see the next output parameter description) brings the board pattern\n* from the model coordinate space (in which object points are specified) to the world coordinate\n* space, that is, a real position of the board pattern in the k-th pattern view (k=0.. *M* -1).\n* @param tvecs Output vector of translation vectors estimated for each pattern view.\n* @param stdDeviationsIntrinsics Output vector of standard deviations estimated for intrinsic parameters.\n* Order of deviations values:\n* \\f$(f_x, f_y, c_x, c_y, k_1, k_2, p_1, p_2, k_3, k_4, k_5, k_6 , s_1, s_2, s_3,\n* s_4, \\tau_x, \\tau_y)\\f$ If one of parameters is not estimated, it's deviation is equals to zero.\n* @param stdDeviationsExtrinsics Output vector of standard deviations estimated for extrinsic parameters.\n* Order of deviations values: \\f$(R_1, T_1, \\dotsc , R_M, T_M)\\f$ where M is number of pattern views,\n* \\f$R_i, T_i\\f$ are concatenated 1x3 vectors.\n* @param perViewErrors Output vector of average re-projection errors estimated for each pattern view.\n* @param flags flags Different flags  for the calibration process (see #calibrateCamera for details).\n* @param criteria Termination criteria for the iterative optimization algorithm.\n*\n* This function calibrates a camera using an Aruco Board. The function receives a list of\n* detected markers from several views of the Board. The process is similar to the chessboard\n* calibration in calibrateCamera(). The function returns the final re-projection error."]
ok: FUNC <double cv.aruco..calibrateCameraAruco [ARG vector_Mat corners=, ARG Mat ids=, ARG Mat counter=, ARG Ptr_Board board=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat stdDeviationsIntrinsics=, ARG Mat stdDeviationsExtrinsics=, ARG Mat perViewErrors=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>

--- Incoming ---
[   u'cv.aruco.calibrateCameraAruco',
    u'double',
    [],
    [   ['vector_Mat', u'corners', '', []],
        ['Mat', u'ids', '', []],
        ['Mat', u'counter', '', []],
        [u'Ptr_Board', u'board', u'', ['/C', '/Ref']],
        [u'Size', u'imageSize', u'', []],
        ['Mat', u'cameraMatrix', '', ['/IO']],
        ['Mat', u'distCoeffs', '', ['/IO']],
        ['vector_Mat', u'rvecs', u'vector_Mat()', ['/O']],
        ['vector_Mat', u'tvecs', u'vector_Mat()', ['/O']],
        [u'int', u'flags', u'0', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)',
            []]],
    u'double',
    u"@brief It's the same function as #calibrateCameraAruco but without calibration error estimation."]
ok: FUNC <double cv.aruco..calibrateCameraAruco [ARG vector_Mat corners=, ARG Mat ids=, ARG Mat counter=, ARG Ptr_Board board=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=vector_Mat(), ARG vector_Mat tvecs=vector_Mat(), ARG int flags=0, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>

--- Incoming ---
[   u'cv.aruco.getBoardObjectAndImagePoints',
    u'void',
    [],
    [   [u'Ptr_Board', u'board', u'', ['/C', '/Ref']],
        ['vector_Mat', u'detectedCorners', '', []],
        ['Mat', u'detectedIds', '', []],
        ['Mat', u'objPoints', '', ['/O']],
        ['Mat', u'imgPoints', '', ['/O']]],
    u'void',
    u'* @brief Given a board configuration and a set of detected markers, returns the corresponding\n* image points and object points to call solvePnP\n*\n* @param board Marker board layout.\n* @param detectedCorners List of detected marker corners of the board.\n* @param detectedIds List of identifiers for each marker.\n* @param objPoints Vector of vectors of board marker points in the board coordinate space.\n* @param imgPoints Vector of vectors of the projections of board marker corner points.']
ok: FUNC <void cv.aruco..getBoardObjectAndImagePoints [ARG Ptr_Board board=, ARG vector_Mat detectedCorners=, ARG Mat detectedIds=, ARG Mat objPoints=, ARG Mat imgPoints=]>


===== Header: /Users/Chao/opencv_contrib/modules/aruco/include/opencv2/aruco/charuco.hpp =====
Namespaces: set([u'cv.aruco', u'cv'])

--- Incoming ---
[   u'class cv.aruco.CharucoBoard',
    u': cv::aruco::Board',
    [],
    [   [u'vector_Point3f', u'chessboardCorners', '', []],
        [u'vector_vector_int', u'nearestMarkerIdx', '', []],
        [u'vector_vector_int', u'nearestMarkerCorners', '', []]],
    None,
    u'* @brief ChArUco board\n* Specific class for ChArUco boards. A ChArUco board is a planar board where the markers are placed\n* inside the white squares of a chessboard. The benefits of ChArUco boards is that they provide\n* both, ArUco markers versatility and chessboard corner precision, which is important for\n* calibration and pose estimation.\n* This class also allows the easy creation and drawing of ChArUco boards.']
ok: class CLASS cv.aruco::.CharucoBoard : Board, name: CharucoBoard, base: Board

--- Incoming ---
[   u'cv.aruco.CharucoBoard.draw',
    u'void',
    [],
    [   [u'Size', u'outSize', u'', []],
        ['Mat', u'img', '', ['/O']],
        [u'int', u'marginSize', u'0', []],
        [u'int', u'borderBits', u'1', []]],
    u'void',
    u'* @brief Draw a ChArUco board\n*\n* @param outSize size of the output image in pixels.\n* @param img output image with the board. The size of this image will be outSize\n* and the board will be on the center, keeping the board proportions.\n* @param marginSize minimum margins (in pixels) of the board in the output image\n* @param borderBits width of the marker borders.\n*\n* This function return the image of the ChArUco board, ready to be printed.']
ok: FUNC <void cv.aruco.CharucoBoard.draw [ARG Size outSize=, ARG Mat img=, ARG int marginSize=0, ARG int borderBits=1]>

--- Incoming ---
[   u'cv.aruco.CharucoBoard.create',
    u'Ptr_CharucoBoard',
    ['/S'],
    [   [u'int', u'squaresX', u'', []],
        [u'int', u'squaresY', u'', []],
        [u'float', u'squareLength', u'', []],
        [u'float', u'markerLength', u'', []],
        [u'Ptr_Dictionary', u'dictionary', u'', ['/C', '/Ref']]],
    u'Ptr<CharucoBoard>',
    u'* @brief Create a CharucoBoard object\n*\n* @param squaresX number of chessboard squares in X direction\n* @param squaresY number of chessboard squares in Y direction\n* @param squareLength chessboard square side length (normally in meters)\n* @param markerLength marker side length (same unit than squareLength)\n* @param dictionary dictionary of markers indicating the type of markers.\n* The first markers in the dictionary are used to fill the white chessboard squares.\n* @return the output CharucoBoard object\n*\n* This functions creates a CharucoBoard object given the number of squares in each direction\n* and the size of the markers and chessboard squares.']
ok: FUNC <Ptr_CharucoBoard cv.aruco.CharucoBoard.create [ARG int squaresX=, ARG int squaresY=, ARG float squareLength=, ARG float markerLength=, ARG Ptr_Dictionary dictionary=]>

--- Incoming ---
[   u'cv.aruco.CharucoBoard.getChessboardSize',
    u'Size',
    ['/C'],
    [],
    u'Size',
    u'*']
ok: FUNC <Size cv.aruco.CharucoBoard.getChessboardSize []>

--- Incoming ---
[   u'cv.aruco.CharucoBoard.getSquareLength',
    u'float',
    ['/C'],
    [],
    u'float',
    u'*']
ok: FUNC <float cv.aruco.CharucoBoard.getSquareLength []>

--- Incoming ---
[   u'cv.aruco.CharucoBoard.getMarkerLength',
    u'float',
    ['/C'],
    [],
    u'float',
    u'*']
ok: FUNC <float cv.aruco.CharucoBoard.getMarkerLength []>

--- Incoming ---
[   u'cv.aruco.interpolateCornersCharuco',
    u'int',
    [],
    [   ['vector_Mat', u'markerCorners', '', []],
        ['Mat', u'markerIds', '', []],
        ['Mat', u'image', '', []],
        [u'Ptr_CharucoBoard', u'board', u'', ['/C', '/Ref']],
        ['Mat', u'charucoCorners', '', ['/O']],
        ['Mat', u'charucoIds', '', ['/O']],
        ['Mat', u'cameraMatrix', u'Mat()', []],
        ['Mat', u'distCoeffs', u'Mat()', []],
        [u'int', u'minMarkers', u'2', []]],
    u'int',
    u'* @brief Interpolate position of ChArUco board corners\n* @param markerCorners vector of already detected markers corners. For each marker, its four\n* corners are provided, (e.g std::vector<std::vector<cv::Point2f> > ). For N detected markers, the\n* dimensions of this array should be Nx4. The order of the corners should be clockwise.\n* @param markerIds list of identifiers for each marker in corners\n* @param image input image necesary for corner refinement. Note that markers are not detected and\n* should be sent in corners and ids parameters.\n* @param board layout of ChArUco board.\n* @param charucoCorners interpolated chessboard corners\n* @param charucoIds interpolated chessboard corners identifiers\n* @param cameraMatrix optional 3x3 floating-point camera matrix\n* \\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$\n* @param distCoeffs optional vector of distortion coefficients\n* \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6],[s_1, s_2, s_3, s_4]])\\f$ of 4, 5, 8 or 12 elements\n* @param minMarkers number of adjacent markers that must be detected to return a charuco corner\n*\n* This function receives the detected markers and returns the 2D position of the chessboard corners\n* from a ChArUco board using the detected Aruco markers. If camera parameters are provided,\n* the process is based in an approximated pose estimation, else it is based on local homography.\n* Only visible corners are returned. For each corner, its corresponding identifier is\n* also returned in charucoIds.\n* The function returns the number of interpolated corners.']
ok: FUNC <int cv.aruco..interpolateCornersCharuco [ARG vector_Mat markerCorners=, ARG Mat markerIds=, ARG Mat image=, ARG Ptr_CharucoBoard board=, ARG Mat charucoCorners=, ARG Mat charucoIds=, ARG Mat cameraMatrix=Mat(), ARG Mat distCoeffs=Mat(), ARG int minMarkers=2]>

--- Incoming ---
[   u'cv.aruco.estimatePoseCharucoBoard',
    u'bool',
    [],
    [   ['Mat', u'charucoCorners', '', []],
        ['Mat', u'charucoIds', '', []],
        [u'Ptr_CharucoBoard', u'board', u'', ['/C', '/Ref']],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'rvec', '', ['/O']],
        ['Mat', u'tvec', '', ['/O']],
        [u'bool', u'useExtrinsicGuess', u'false', []]],
    u'bool',
    u'* @brief Pose estimation for a ChArUco board given some of their corners\n* @param charucoCorners vector of detected charuco corners\n* @param charucoIds list of identifiers for each corner in charucoCorners\n* @param board layout of ChArUco board.\n* @param cameraMatrix input 3x3 floating-point camera matrix\n* \\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$\n* @param distCoeffs vector of distortion coefficients\n* \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6],[s_1, s_2, s_3, s_4]])\\f$ of 4, 5, 8 or 12 elements\n* @param rvec Output vector (e.g. cv::Mat) corresponding to the rotation vector of the board\n* (see cv::Rodrigues).\n* @param tvec Output vector (e.g. cv::Mat) corresponding to the translation vector of the board.\n* @param useExtrinsicGuess defines whether initial guess for \\b rvec and \\b tvec will be used or not.\n*\n* This function estimates a Charuco board pose from some detected corners.\n* The function checks if the input corners are enough and valid to perform pose estimation.\n* If pose estimation is valid, returns true, else returns false.']
ok: FUNC <bool cv.aruco..estimatePoseCharucoBoard [ARG Mat charucoCorners=, ARG Mat charucoIds=, ARG Ptr_CharucoBoard board=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false]>

--- Incoming ---
[   u'cv.aruco.drawDetectedCornersCharuco',
    u'void',
    [],
    [   ['Mat', u'image', '', ['/IO']],
        ['Mat', u'charucoCorners', '', []],
        ['Mat', u'charucoIds', u'Mat()', []],
        [u'Scalar', u'cornerColor', u'Scalar(255, 0, 0)', []]],
    u'void',
    u'* @brief Draws a set of Charuco corners\n* @param image input/output image. It must have 1 or 3 channels. The number of channels is not\n* altered.\n* @param charucoCorners vector of detected charuco corners\n* @param charucoIds list of identifiers for each corner in charucoCorners\n* @param cornerColor color of the square surrounding each corner\n*\n* This function draws a set of detected Charuco corners. If identifiers vector is provided, it also\n* draws the id of each corner.']
ok: FUNC <void cv.aruco..drawDetectedCornersCharuco [ARG Mat image=, ARG Mat charucoCorners=, ARG Mat charucoIds=Mat(), ARG Scalar cornerColor=Scalar(255, 0, 0)]>

--- Incoming ---
[   u'cv.aruco.calibrateCameraCharuco',
    u'double',
    [u'=calibrateCameraCharucoExtended'],
    [   ['vector_Mat', u'charucoCorners', '', []],
        ['vector_Mat', u'charucoIds', '', []],
        [u'Ptr_CharucoBoard', u'board', u'', ['/C', '/Ref']],
        [u'Size', u'imageSize', u'', []],
        ['Mat', u'cameraMatrix', '', ['/IO']],
        ['Mat', u'distCoeffs', '', ['/IO']],
        ['vector_Mat', u'rvecs', '', ['/O']],
        ['vector_Mat', u'tvecs', '', ['/O']],
        ['Mat', u'stdDeviationsIntrinsics', '', ['/O']],
        ['Mat', u'stdDeviationsExtrinsics', '', ['/O']],
        ['Mat', u'perViewErrors', '', ['/O']],
        [u'int', u'flags', u'0', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)',
            []]],
    u'double',
    u"* @brief Calibrate a camera using Charuco corners\n*\n* @param charucoCorners vector of detected charuco corners per frame\n* @param charucoIds list of identifiers for each corner in charucoCorners per frame\n* @param board Marker Board layout\n* @param imageSize input image size\n* @param cameraMatrix Output 3x3 floating-point camera matrix\n* \\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ . If CV\\_CALIB\\_USE\\_INTRINSIC\\_GUESS\n* and/or CV_CALIB_FIX_ASPECT_RATIO are specified, some or all of fx, fy, cx, cy must be\n* initialized before calling the function.\n* @param distCoeffs Output vector of distortion coefficients\n* \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6],[s_1, s_2, s_3, s_4]])\\f$ of 4, 5, 8 or 12 elements\n* @param rvecs Output vector of rotation vectors (see Rodrigues ) estimated for each board view\n* (e.g. std::vector<cv::Mat>>). That is, each k-th rotation vector together with the corresponding\n* k-th translation vector (see the next output parameter description) brings the board pattern\n* from the model coordinate space (in which object points are specified) to the world coordinate\n* space, that is, a real position of the board pattern in the k-th pattern view (k=0.. *M* -1).\n* @param tvecs Output vector of translation vectors estimated for each pattern view.\n* @param stdDeviationsIntrinsics Output vector of standard deviations estimated for intrinsic parameters.\n* Order of deviations values:\n* \\f$(f_x, f_y, c_x, c_y, k_1, k_2, p_1, p_2, k_3, k_4, k_5, k_6 , s_1, s_2, s_3,\n* s_4, \\tau_x, \\tau_y)\\f$ If one of parameters is not estimated, it's deviation is equals to zero.\n* @param stdDeviationsExtrinsics Output vector of standard deviations estimated for extrinsic parameters.\n* Order of deviations values: \\f$(R_1, T_1, \\dotsc , R_M, T_M)\\f$ where M is number of pattern views,\n* \\f$R_i, T_i\\f$ are concatenated 1x3 vectors.\n* @param perViewErrors Output vector of average re-projection errors estimated for each pattern view.\n* @param flags flags Different flags  for the calibration process (see #calibrateCamera for details).\n* @param criteria Termination criteria for the iterative optimization algorithm.\n*\n* This function calibrates a camera using a set of corners of a  Charuco Board. The function\n* receives a list of detected corners and its identifiers from several views of the Board.\n* The function returns the final re-projection error."]
ok: FUNC <double cv.aruco..calibrateCameraCharuco [ARG vector_Mat charucoCorners=, ARG vector_Mat charucoIds=, ARG Ptr_CharucoBoard board=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat stdDeviationsIntrinsics=, ARG Mat stdDeviationsExtrinsics=, ARG Mat perViewErrors=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>

--- Incoming ---
[   u'cv.aruco.calibrateCameraCharuco',
    u'double',
    [],
    [   ['vector_Mat', u'charucoCorners', '', []],
        ['vector_Mat', u'charucoIds', '', []],
        [u'Ptr_CharucoBoard', u'board', u'', ['/C', '/Ref']],
        [u'Size', u'imageSize', u'', []],
        ['Mat', u'cameraMatrix', '', ['/IO']],
        ['Mat', u'distCoeffs', '', ['/IO']],
        ['vector_Mat', u'rvecs', u'vector_Mat()', ['/O']],
        ['vector_Mat', u'tvecs', u'vector_Mat()', ['/O']],
        [u'int', u'flags', u'0', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)',
            []]],
    u'double',
    u"@brief It's the same function as #calibrateCameraCharuco but without calibration error estimation."]
ok: FUNC <double cv.aruco..calibrateCameraCharuco [ARG vector_Mat charucoCorners=, ARG vector_Mat charucoIds=, ARG Ptr_CharucoBoard board=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=vector_Mat(), ARG vector_Mat tvecs=vector_Mat(), ARG int flags=0, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>

--- Incoming ---
[   u'cv.aruco.detectCharucoDiamond',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        ['vector_Mat', u'markerCorners', '', []],
        ['Mat', u'markerIds', '', []],
        [u'float', u'squareMarkerLengthRate', u'', []],
        ['vector_Mat', u'diamondCorners', '', ['/O']],
        ['Mat', u'diamondIds', '', ['/O']],
        ['Mat', u'cameraMatrix', u'Mat()', []],
        ['Mat', u'distCoeffs', u'Mat()', []]],
    u'void',
    u'* @brief Detect ChArUco Diamond markers\n*\n* @param image input image necessary for corner subpixel.\n* @param markerCorners list of detected marker corners from detectMarkers function.\n* @param markerIds list of marker ids in markerCorners.\n* @param squareMarkerLengthRate rate between square and marker length:\n* squareMarkerLengthRate = squareLength/markerLength. The real units are not necessary.\n* @param diamondCorners output list of detected diamond corners (4 corners per diamond). The order\n* is the same than in marker corners: top left, top right, bottom right and bottom left. Similar\n* format than the corners returned by detectMarkers (e.g std::vector<std::vector<cv::Point2f> > ).\n* @param diamondIds ids of the diamonds in diamondCorners. The id of each diamond is in fact of\n* type Vec4i, so each diamond has 4 ids, which are the ids of the aruco markers composing the\n* diamond.\n* @param cameraMatrix Optional camera calibration matrix.\n* @param distCoeffs Optional camera distortion coefficients.\n*\n* This function detects Diamond markers from the previous detected ArUco markers. The diamonds\n* are returned in the diamondCorners and diamondIds parameters. If camera calibration parameters\n* are provided, the diamond search is based on reprojection. If not, diamond search is based on\n* homography. Homography is faster than reprojection but can slightly reduce the detection rate.']
ok: FUNC <void cv.aruco..detectCharucoDiamond [ARG Mat image=, ARG vector_Mat markerCorners=, ARG Mat markerIds=, ARG float squareMarkerLengthRate=, ARG vector_Mat diamondCorners=, ARG Mat diamondIds=, ARG Mat cameraMatrix=Mat(), ARG Mat distCoeffs=Mat()]>

--- Incoming ---
[   u'cv.aruco.drawDetectedDiamonds',
    u'void',
    [],
    [   ['Mat', u'image', '', ['/IO']],
        ['vector_Mat', u'diamondCorners', '', []],
        ['Mat', u'diamondIds', u'Mat()', []],
        [u'Scalar', u'borderColor', u'Scalar(0, 0, 255)', []]],
    u'void',
    u'* @brief Draw a set of detected ChArUco Diamond markers\n*\n* @param image input/output image. It must have 1 or 3 channels. The number of channels is not\n* altered.\n* @param diamondCorners positions of diamond corners in the same format returned by\n* detectCharucoDiamond(). (e.g std::vector<std::vector<cv::Point2f> > ). For N detected markers,\n* the dimensions of this array should be Nx4. The order of the corners should be clockwise.\n* @param diamondIds vector of identifiers for diamonds in diamondCorners, in the same format\n* returned by detectCharucoDiamond() (e.g. std::vector<Vec4i>).\n* Optional, if not provided, ids are not painted.\n* @param borderColor color of marker borders. Rest of colors (text color and first corner color)\n* are calculated based on this one.\n*\n* Given an array of detected diamonds, this functions draws them in the image. The marker borders\n* are painted and the markers identifiers if provided.\n* Useful for debugging purposes.']
ok: FUNC <void cv.aruco..drawDetectedDiamonds [ARG Mat image=, ARG vector_Mat diamondCorners=, ARG Mat diamondIds=Mat(), ARG Scalar borderColor=Scalar(0, 0, 255)]>


===== Header: /Users/Chao/opencv_contrib/modules/aruco/include/opencv2/aruco/dictionary.hpp =====
Namespaces: set([u'cv.aruco', u'cv'])

--- Incoming ---
[   u'class cv.aruco.Dictionary',
    '',
    [],
    [   [u'Mat', u'bytesList', '', []],
        [u'int', u'markerSize', '', []],
        [u'int', u'maxCorrectionBits', '', []]],
    None,
    u'* @brief Dictionary/Set of markers. It contains the inner codification\n*\n* bytesList contains the marker codewords where\n* - bytesList.rows is the dictionary size\n* - each marker is encoded using `nbytes = ceil(markerSize*markerSize/8.)`\n* - each row contains all 4 rotations of the marker, so its length is `4*nbytes`\n*\n* `bytesList.ptr(i)[k*nbytes + j]` is then the j-th byte of i-th marker, in its k-th rotation.']
ok: class CLASS cv.aruco::.Dictionary : , name: Dictionary, base: 

--- Incoming ---
[   u'cv.aruco.Dictionary.create',
    u'Ptr_Dictionary',
    [u'=create', '/S'],
    [[u'int', u'nMarkers', u'', []], [u'int', u'markerSize', u'', []]],
    u'Ptr<Dictionary>',
    u'* @see generateCustomDictionary']
ok: FUNC <Ptr_Dictionary cv.aruco.Dictionary.create [ARG int nMarkers=, ARG int markerSize=]>

--- Incoming ---
[   u'cv.aruco.Dictionary.create',
    u'Ptr_Dictionary',
    [u'=create_from', '/S'],
    [   [u'int', u'nMarkers', u'', []],
        [u'int', u'markerSize', u'', []],
        [u'Ptr_Dictionary', u'baseDictionary', u'', ['/C', '/Ref']]],
    u'Ptr<Dictionary>',
    u'* @see generateCustomDictionary']
ok: FUNC <Ptr_Dictionary cv.aruco.Dictionary.create [ARG int nMarkers=, ARG int markerSize=, ARG Ptr_Dictionary baseDictionary=]>

--- Incoming ---
[   u'cv.aruco.Dictionary.get',
    u'Ptr_Dictionary',
    ['/S'],
    [[u'int', u'dict', u'', []]],
    u'Ptr<Dictionary>',
    u'* @see getPredefinedDictionary']
ok: FUNC <Ptr_Dictionary cv.aruco.Dictionary.get [ARG int dict=]>

--- Incoming ---
[   u'cv.aruco.Dictionary.drawMarker',
    u'void',
    ['/C'],
    [   [u'int', u'id', u'', []],
        [u'int', u'sidePixels', u'', []],
        ['Mat', u'_img', '', ['/O']],
        [u'int', u'borderBits', u'1', []]],
    u'void',
    u'* @brief Draw a canonical marker image']
ok: FUNC <void cv.aruco.Dictionary.drawMarker [ARG int id=, ARG int sidePixels=, ARG Mat _img=, ARG int borderBits=1]>

--- Incoming ---
[u'const cv.aruco.DICT_4X4_50', u'0', [], [], None, '']
ok: CONST DICT_4X4_50=0

--- Incoming ---
[u'const cv.aruco.DICT_4X4_100', u'0+1', [], [], None, '']
ok: CONST DICT_4X4_100=0+1

--- Incoming ---
[u'const cv.aruco.DICT_4X4_250', u'0+2', [], [], None, '']
ok: CONST DICT_4X4_250=0+2

--- Incoming ---
[u'const cv.aruco.DICT_4X4_1000', u'0+3', [], [], None, '']
ok: CONST DICT_4X4_1000=0+3

--- Incoming ---
[u'const cv.aruco.DICT_5X5_50', u'0+4', [], [], None, '']
ok: CONST DICT_5X5_50=0+4

--- Incoming ---
[u'const cv.aruco.DICT_5X5_100', u'0+5', [], [], None, '']
ok: CONST DICT_5X5_100=0+5

--- Incoming ---
[u'const cv.aruco.DICT_5X5_250', u'0+6', [], [], None, '']
ok: CONST DICT_5X5_250=0+6

--- Incoming ---
[u'const cv.aruco.DICT_5X5_1000', u'0+7', [], [], None, '']
ok: CONST DICT_5X5_1000=0+7

--- Incoming ---
[u'const cv.aruco.DICT_6X6_50', u'0+8', [], [], None, '']
ok: CONST DICT_6X6_50=0+8

--- Incoming ---
[u'const cv.aruco.DICT_6X6_100', u'0+9', [], [], None, '']
ok: CONST DICT_6X6_100=0+9

--- Incoming ---
[u'const cv.aruco.DICT_6X6_250', u'0+10', [], [], None, '']
ok: CONST DICT_6X6_250=0+10

--- Incoming ---
[u'const cv.aruco.DICT_6X6_1000', u'0+11', [], [], None, '']
ok: CONST DICT_6X6_1000=0+11

--- Incoming ---
[u'const cv.aruco.DICT_7X7_50', u'0+12', [], [], None, '']
ok: CONST DICT_7X7_50=0+12

--- Incoming ---
[u'const cv.aruco.DICT_7X7_100', u'0+13', [], [], None, '']
ok: CONST DICT_7X7_100=0+13

--- Incoming ---
[u'const cv.aruco.DICT_7X7_250', u'0+14', [], [], None, '']
ok: CONST DICT_7X7_250=0+14

--- Incoming ---
[u'const cv.aruco.DICT_7X7_1000', u'0+15', [], [], None, '']
ok: CONST DICT_7X7_1000=0+15

--- Incoming ---
[u'const cv.aruco.DICT_ARUCO_ORIGINAL', u'0+16', [], [], None, '']
ok: CONST DICT_ARUCO_ORIGINAL=0+16

--- Incoming ---
[   u'cv.aruco.getPredefinedDictionary',
    u'Ptr_Dictionary',
    [],
    [[u'int', u'dict', u'', []]],
    u'Ptr<Dictionary>',
    u'* @brief Returns one of the predefined dictionaries referenced by DICT_*.']
ok: FUNC <Ptr_Dictionary cv.aruco..getPredefinedDictionary [ARG int dict=]>

--- Incoming ---
[   u'cv.aruco.generateCustomDictionary',
    u'Ptr_Dictionary',
    [u'=custom_dictionary'],
    [[u'int', u'nMarkers', u'', []], [u'int', u'markerSize', u'', []]],
    u'Ptr<Dictionary>',
    u'* @see generateCustomDictionary']
ok: FUNC <Ptr_Dictionary cv.aruco..generateCustomDictionary [ARG int nMarkers=, ARG int markerSize=]>

--- Incoming ---
[   u'cv.aruco.generateCustomDictionary',
    u'Ptr_Dictionary',
    [u'=custom_dictionary_from'],
    [   [u'int', u'nMarkers', u'', []],
        [u'int', u'markerSize', u'', []],
        [u'Ptr_Dictionary', u'baseDictionary', u'', ['/C', '/Ref']]],
    u'Ptr<Dictionary>',
    u'* @brief Generates a new customizable marker dictionary\n*\n* @param nMarkers number of markers in the dictionary\n* @param markerSize number of bits per dimension of each markers\n* @param baseDictionary Include the markers in this dictionary at the beginning (optional)\n*\n* This function creates a new dictionary composed by nMarkers markers and each markers composed\n* by markerSize x markerSize bits. If baseDictionary is provided, its markers are directly\n* included and the rest are generated based on them. If the size of baseDictionary is higher\n* than nMarkers, only the first nMarkers in baseDictionary are taken and no new marker is added.']
ok: FUNC <Ptr_Dictionary cv.aruco..generateCustomDictionary [ARG int nMarkers=, ARG int markerSize=, ARG Ptr_Dictionary baseDictionary=]>


===== Generating... =====
CLASS cv.aruco::.DetectorParameters : 
FUNC <Ptr_DetectorParameters cv.aruco.DetectorParameters.create []>
java: DetectorParameters create()
FUNC <int cv.aruco.DetectorParameters.get_adaptiveThreshWinSizeMin []>
java: int get_adaptiveThreshWinSizeMin()
FUNC <void cv.aruco.DetectorParameters.set_adaptiveThreshWinSizeMin [ARG int adaptiveThreshWinSizeMin=]>
java: void set_adaptiveThreshWinSizeMin(int adaptiveThreshWinSizeMin)
FUNC <int cv.aruco.DetectorParameters.get_adaptiveThreshWinSizeMax []>
java: int get_adaptiveThreshWinSizeMax()
FUNC <void cv.aruco.DetectorParameters.set_adaptiveThreshWinSizeMax [ARG int adaptiveThreshWinSizeMax=]>
java: void set_adaptiveThreshWinSizeMax(int adaptiveThreshWinSizeMax)
FUNC <int cv.aruco.DetectorParameters.get_adaptiveThreshWinSizeStep []>
java: int get_adaptiveThreshWinSizeStep()
FUNC <void cv.aruco.DetectorParameters.set_adaptiveThreshWinSizeStep [ARG int adaptiveThreshWinSizeStep=]>
java: void set_adaptiveThreshWinSizeStep(int adaptiveThreshWinSizeStep)
FUNC <double cv.aruco.DetectorParameters.get_adaptiveThreshConstant []>
java: double get_adaptiveThreshConstant()
FUNC <void cv.aruco.DetectorParameters.set_adaptiveThreshConstant [ARG double adaptiveThreshConstant=]>
java: void set_adaptiveThreshConstant(double adaptiveThreshConstant)
FUNC <double cv.aruco.DetectorParameters.get_minMarkerPerimeterRate []>
java: double get_minMarkerPerimeterRate()
FUNC <void cv.aruco.DetectorParameters.set_minMarkerPerimeterRate [ARG double minMarkerPerimeterRate=]>
java: void set_minMarkerPerimeterRate(double minMarkerPerimeterRate)
FUNC <double cv.aruco.DetectorParameters.get_maxMarkerPerimeterRate []>
java: double get_maxMarkerPerimeterRate()
FUNC <void cv.aruco.DetectorParameters.set_maxMarkerPerimeterRate [ARG double maxMarkerPerimeterRate=]>
java: void set_maxMarkerPerimeterRate(double maxMarkerPerimeterRate)
FUNC <double cv.aruco.DetectorParameters.get_polygonalApproxAccuracyRate []>
java: double get_polygonalApproxAccuracyRate()
FUNC <void cv.aruco.DetectorParameters.set_polygonalApproxAccuracyRate [ARG double polygonalApproxAccuracyRate=]>
java: void set_polygonalApproxAccuracyRate(double polygonalApproxAccuracyRate)
FUNC <double cv.aruco.DetectorParameters.get_minCornerDistanceRate []>
java: double get_minCornerDistanceRate()
FUNC <void cv.aruco.DetectorParameters.set_minCornerDistanceRate [ARG double minCornerDistanceRate=]>
java: void set_minCornerDistanceRate(double minCornerDistanceRate)
FUNC <int cv.aruco.DetectorParameters.get_minDistanceToBorder []>
java: int get_minDistanceToBorder()
FUNC <void cv.aruco.DetectorParameters.set_minDistanceToBorder [ARG int minDistanceToBorder=]>
java: void set_minDistanceToBorder(int minDistanceToBorder)
FUNC <double cv.aruco.DetectorParameters.get_minMarkerDistanceRate []>
java: double get_minMarkerDistanceRate()
FUNC <void cv.aruco.DetectorParameters.set_minMarkerDistanceRate [ARG double minMarkerDistanceRate=]>
java: void set_minMarkerDistanceRate(double minMarkerDistanceRate)
FUNC <int cv.aruco.DetectorParameters.get_cornerRefinementMethod []>
java: int get_cornerRefinementMethod()
FUNC <void cv.aruco.DetectorParameters.set_cornerRefinementMethod [ARG int cornerRefinementMethod=]>
java: void set_cornerRefinementMethod(int cornerRefinementMethod)
FUNC <int cv.aruco.DetectorParameters.get_cornerRefinementWinSize []>
java: int get_cornerRefinementWinSize()
FUNC <void cv.aruco.DetectorParameters.set_cornerRefinementWinSize [ARG int cornerRefinementWinSize=]>
java: void set_cornerRefinementWinSize(int cornerRefinementWinSize)
FUNC <int cv.aruco.DetectorParameters.get_cornerRefinementMaxIterations []>
java: int get_cornerRefinementMaxIterations()
FUNC <void cv.aruco.DetectorParameters.set_cornerRefinementMaxIterations [ARG int cornerRefinementMaxIterations=]>
java: void set_cornerRefinementMaxIterations(int cornerRefinementMaxIterations)
FUNC <double cv.aruco.DetectorParameters.get_cornerRefinementMinAccuracy []>
java: double get_cornerRefinementMinAccuracy()
FUNC <void cv.aruco.DetectorParameters.set_cornerRefinementMinAccuracy [ARG double cornerRefinementMinAccuracy=]>
java: void set_cornerRefinementMinAccuracy(double cornerRefinementMinAccuracy)
FUNC <int cv.aruco.DetectorParameters.get_markerBorderBits []>
java: int get_markerBorderBits()
FUNC <void cv.aruco.DetectorParameters.set_markerBorderBits [ARG int markerBorderBits=]>
java: void set_markerBorderBits(int markerBorderBits)
FUNC <int cv.aruco.DetectorParameters.get_perspectiveRemovePixelPerCell []>
java: int get_perspectiveRemovePixelPerCell()
FUNC <void cv.aruco.DetectorParameters.set_perspectiveRemovePixelPerCell [ARG int perspectiveRemovePixelPerCell=]>
java: void set_perspectiveRemovePixelPerCell(int perspectiveRemovePixelPerCell)
FUNC <double cv.aruco.DetectorParameters.get_perspectiveRemoveIgnoredMarginPerCell []>
java: double get_perspectiveRemoveIgnoredMarginPerCell()
FUNC <void cv.aruco.DetectorParameters.set_perspectiveRemoveIgnoredMarginPerCell [ARG double perspectiveRemoveIgnoredMarginPerCell=]>
java: void set_perspectiveRemoveIgnoredMarginPerCell(double perspectiveRemoveIgnoredMarginPerCell)
FUNC <double cv.aruco.DetectorParameters.get_maxErroneousBitsInBorderRate []>
java: double get_maxErroneousBitsInBorderRate()
FUNC <void cv.aruco.DetectorParameters.set_maxErroneousBitsInBorderRate [ARG double maxErroneousBitsInBorderRate=]>
java: void set_maxErroneousBitsInBorderRate(double maxErroneousBitsInBorderRate)
FUNC <double cv.aruco.DetectorParameters.get_minOtsuStdDev []>
java: double get_minOtsuStdDev()
FUNC <void cv.aruco.DetectorParameters.set_minOtsuStdDev [ARG double minOtsuStdDev=]>
java: void set_minOtsuStdDev(double minOtsuStdDev)
FUNC <double cv.aruco.DetectorParameters.get_errorCorrectionRate []>
java: double get_errorCorrectionRate()
FUNC <void cv.aruco.DetectorParameters.set_errorCorrectionRate [ARG double errorCorrectionRate=]>
java: void set_errorCorrectionRate(double errorCorrectionRate)
CLASS cv.aruco::.CharucoBoard : Board
FUNC <Ptr_CharucoBoard cv.aruco.CharucoBoard.create [ARG int squaresX=, ARG int squaresY=, ARG float squareLength=, ARG float markerLength=, ARG Ptr_Dictionary dictionary=]>
java: CharucoBoard create(int squaresX, int squaresY, float squareLength, float markerLength, Dictionary dictionary)
FUNC <Size cv.aruco.CharucoBoard.getChessboardSize []>
java: Size getChessboardSize()
FUNC <float cv.aruco.CharucoBoard.getMarkerLength []>
java: float getMarkerLength()
FUNC <float cv.aruco.CharucoBoard.getSquareLength []>
java: float getSquareLength()
FUNC <void cv.aruco.CharucoBoard.draw [ARG Size outSize=, ARG Mat img=, ARG int marginSize=0, ARG int borderBits=1]>
java: void draw(Size outSize, Mat img, int marginSize, int borderBits)
java: void draw(Size outSize, Mat img)
FUNC <vector_Point3f cv.aruco.CharucoBoard.get_chessboardCorners []>
java: MatOfPoint3f get_chessboardCorners()
FUNC <vector_vector_int cv.aruco.CharucoBoard.get_nearestMarkerIdx []>
SKIP:vector_vector_int CharucoBoard::nearestMarkerIdx	 due to RET typevector_vector_int
FUNC <vector_vector_int cv.aruco.CharucoBoard.get_nearestMarkerCorners []>
SKIP:vector_vector_int CharucoBoard::nearestMarkerCorners	 due to RET typevector_vector_int
CLASS cv.aruco::.Dictionary : 
FUNC <Ptr_Dictionary cv.aruco.Dictionary.create [ARG int nMarkers=, ARG int markerSize=, ARG Ptr_Dictionary baseDictionary=]>
java: Dictionary create_from(int nMarkers, int markerSize, Dictionary baseDictionary)
FUNC <Ptr_Dictionary cv.aruco.Dictionary.create [ARG int nMarkers=, ARG int markerSize=]>
java: Dictionary create(int nMarkers, int markerSize)
FUNC <Ptr_Dictionary cv.aruco.Dictionary.get [ARG int dict=]>
java: Dictionary get(int dict)
FUNC <void cv.aruco.Dictionary.drawMarker [ARG int id=, ARG int sidePixels=, ARG Mat _img=, ARG int borderBits=1]>
java: void drawMarker(int id, int sidePixels, Mat _img, int borderBits)
java: void drawMarker(int id, int sidePixels, Mat _img)
FUNC <Mat cv.aruco.Dictionary.get_bytesList []>
java: Mat get_bytesList()
FUNC <int cv.aruco.Dictionary.get_markerSize []>
java: int get_markerSize()
FUNC <int cv.aruco.Dictionary.get_maxCorrectionBits []>
java: int get_maxCorrectionBits()
CLASS cv.aruco::.GridBoard : Board
FUNC <Ptr_GridBoard cv.aruco.GridBoard.create [ARG int markersX=, ARG int markersY=, ARG float markerLength=, ARG float markerSeparation=, ARG Ptr_Dictionary dictionary=, ARG int firstMarker=0]>
java: GridBoard create(int markersX, int markersY, float markerLength, float markerSeparation, Dictionary dictionary, int firstMarker)
java: GridBoard create(int markersX, int markersY, float markerLength, float markerSeparation, Dictionary dictionary)
FUNC <Size cv.aruco.GridBoard.getGridSize []>
java: Size getGridSize()
FUNC <float cv.aruco.GridBoard.getMarkerLength []>
java: float getMarkerLength()
FUNC <float cv.aruco.GridBoard.getMarkerSeparation []>
java: float getMarkerSeparation()
FUNC <void cv.aruco.GridBoard.draw [ARG Size outSize=, ARG Mat img=, ARG int marginSize=0, ARG int borderBits=1]>
java: void draw(Size outSize, Mat img, int marginSize, int borderBits)
java: void draw(Size outSize, Mat img)
CLASS cv.aruco::.Board : 
FUNC <Ptr_Board cv.aruco.Board.create [ARG vector_Mat objPoints=, ARG Ptr_Dictionary dictionary=, ARG Mat ids=]>
java: Board create(List<Mat> objPoints, Dictionary dictionary, Mat ids)
FUNC <vector_vector_Point3f cv.aruco.Board.get_objPoints []>
java: List<MatOfPoint3f> get_objPoints()
FUNC <Ptr_Dictionary cv.aruco.Board.get_dictionary []>
java: Dictionary get_dictionary()
FUNC <vector_int cv.aruco.Board.get_ids []>
java: MatOfInt get_ids()
CLASS ::.Aruco : 
[CONST CORNER_REFINE_NONE=0, CONST CORNER_REFINE_SUBPIX=1, CONST CORNER_REFINE_CONTOUR=2, CONST DICT_4X4_50=0, CONST DICT_4X4_100=0+1, CONST DICT_4X4_250=0+2, CONST DICT_4X4_1000=0+3, CONST DICT_5X5_50=0+4, CONST DICT_5X5_100=0+5, CONST DICT_5X5_250=0+6, CONST DICT_5X5_1000=0+7, CONST DICT_6X6_50=0+8, CONST DICT_6X6_100=0+9, CONST DICT_6X6_250=0+10, CONST DICT_6X6_1000=0+11, CONST DICT_7X7_50=0+12, CONST DICT_7X7_100=0+13, CONST DICT_7X7_250=0+14, CONST DICT_7X7_1000=0+15, CONST DICT_ARUCO_ORIGINAL=0+16]
FUNC <Ptr_Dictionary cv.aruco..generateCustomDictionary [ARG int nMarkers=, ARG int markerSize=, ARG Ptr_Dictionary baseDictionary=]>
java: Dictionary custom_dictionary_from(int nMarkers, int markerSize, Dictionary baseDictionary)
FUNC <Ptr_Dictionary cv.aruco..generateCustomDictionary [ARG int nMarkers=, ARG int markerSize=]>
java: Dictionary custom_dictionary(int nMarkers, int markerSize)
FUNC <Ptr_Dictionary cv.aruco..getPredefinedDictionary [ARG int dict=]>
java: Dictionary getPredefinedDictionary(int dict)
FUNC <bool cv.aruco..estimatePoseCharucoBoard [ARG Mat charucoCorners=, ARG Mat charucoIds=, ARG Ptr_CharucoBoard board=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false]>
java: boolean estimatePoseCharucoBoard(Mat charucoCorners, Mat charucoIds, CharucoBoard board, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess)
java: boolean estimatePoseCharucoBoard(Mat charucoCorners, Mat charucoIds, CharucoBoard board, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec)
FUNC <double cv.aruco..calibrateCameraAruco [ARG vector_Mat corners=, ARG Mat ids=, ARG Mat counter=, ARG Ptr_Board board=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat stdDeviationsIntrinsics=, ARG Mat stdDeviationsExtrinsics=, ARG Mat perViewErrors=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>
java: double calibrateCameraArucoExtended(List<Mat> corners, Mat ids, Mat counter, Board board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat perViewErrors, int flags, TermCriteria criteria)
java: double calibrateCameraArucoExtended(List<Mat> corners, Mat ids, Mat counter, Board board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat perViewErrors, int flags)
java: double calibrateCameraArucoExtended(List<Mat> corners, Mat ids, Mat counter, Board board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat perViewErrors)
FUNC <double cv.aruco..calibrateCameraAruco [ARG vector_Mat corners=, ARG Mat ids=, ARG Mat counter=, ARG Ptr_Board board=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=vector_Mat(), ARG vector_Mat tvecs=vector_Mat(), ARG int flags=0, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>
java: double calibrateCameraAruco(List<Mat> corners, Mat ids, Mat counter, Board board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, int flags, TermCriteria criteria)
java: double calibrateCameraAruco(List<Mat> corners, Mat ids, Mat counter, Board board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, int flags)
java: double calibrateCameraAruco(List<Mat> corners, Mat ids, Mat counter, Board board, Size imageSize, Mat cameraMatrix, Mat distCoeffs)
FUNC <double cv.aruco..calibrateCameraCharuco [ARG vector_Mat charucoCorners=, ARG vector_Mat charucoIds=, ARG Ptr_CharucoBoard board=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat stdDeviationsIntrinsics=, ARG Mat stdDeviationsExtrinsics=, ARG Mat perViewErrors=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>
java: double calibrateCameraCharucoExtended(List<Mat> charucoCorners, List<Mat> charucoIds, CharucoBoard board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat perViewErrors, int flags, TermCriteria criteria)
java: double calibrateCameraCharucoExtended(List<Mat> charucoCorners, List<Mat> charucoIds, CharucoBoard board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat perViewErrors, int flags)
java: double calibrateCameraCharucoExtended(List<Mat> charucoCorners, List<Mat> charucoIds, CharucoBoard board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat perViewErrors)
FUNC <double cv.aruco..calibrateCameraCharuco [ARG vector_Mat charucoCorners=, ARG vector_Mat charucoIds=, ARG Ptr_CharucoBoard board=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=vector_Mat(), ARG vector_Mat tvecs=vector_Mat(), ARG int flags=0, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>
java: double calibrateCameraCharuco(List<Mat> charucoCorners, List<Mat> charucoIds, CharucoBoard board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, int flags, TermCriteria criteria)
java: double calibrateCameraCharuco(List<Mat> charucoCorners, List<Mat> charucoIds, CharucoBoard board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, int flags)
java: double calibrateCameraCharuco(List<Mat> charucoCorners, List<Mat> charucoIds, CharucoBoard board, Size imageSize, Mat cameraMatrix, Mat distCoeffs)
FUNC <int cv.aruco..estimatePoseBoard [ARG vector_Mat corners=, ARG Mat ids=, ARG Ptr_Board board=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false]>
java: int estimatePoseBoard(List<Mat> corners, Mat ids, Board board, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess)
java: int estimatePoseBoard(List<Mat> corners, Mat ids, Board board, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec)
FUNC <int cv.aruco..interpolateCornersCharuco [ARG vector_Mat markerCorners=, ARG Mat markerIds=, ARG Mat image=, ARG Ptr_CharucoBoard board=, ARG Mat charucoCorners=, ARG Mat charucoIds=, ARG Mat cameraMatrix=Mat(), ARG Mat distCoeffs=Mat(), ARG int minMarkers=2]>
java: int interpolateCornersCharuco(List<Mat> markerCorners, Mat markerIds, Mat image, CharucoBoard board, Mat charucoCorners, Mat charucoIds, Mat cameraMatrix, Mat distCoeffs, int minMarkers)
java: int interpolateCornersCharuco(List<Mat> markerCorners, Mat markerIds, Mat image, CharucoBoard board, Mat charucoCorners, Mat charucoIds)
FUNC <void cv.aruco..detectCharucoDiamond [ARG Mat image=, ARG vector_Mat markerCorners=, ARG Mat markerIds=, ARG float squareMarkerLengthRate=, ARG vector_Mat diamondCorners=, ARG Mat diamondIds=, ARG Mat cameraMatrix=Mat(), ARG Mat distCoeffs=Mat()]>
java: void detectCharucoDiamond(Mat image, List<Mat> markerCorners, Mat markerIds, float squareMarkerLengthRate, List<Mat> diamondCorners, Mat diamondIds, Mat cameraMatrix, Mat distCoeffs)
java: void detectCharucoDiamond(Mat image, List<Mat> markerCorners, Mat markerIds, float squareMarkerLengthRate, List<Mat> diamondCorners, Mat diamondIds)
FUNC <void cv.aruco..detectMarkers [ARG Mat image=, ARG Ptr_Dictionary dictionary=, ARG vector_Mat corners=, ARG Mat ids=, ARG Ptr_DetectorParameters parameters=DetectorParameters::create(), ARG vector_Mat rejectedImgPoints=vector_Mat(), ARG Mat cameraMatrix=Mat(), ARG Mat distCoeff=Mat()]>
java: void detectMarkers(Mat image, Dictionary dictionary, List<Mat> corners, Mat ids, DetectorParameters parameters, List<Mat> rejectedImgPoints, Mat cameraMatrix, Mat distCoeff)
java: void detectMarkers(Mat image, Dictionary dictionary, List<Mat> corners, Mat ids)
FUNC <void cv.aruco..drawAxis [ARG Mat image=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG float length=]>
java: void drawAxis(Mat image, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec, float length)
FUNC <void cv.aruco..drawDetectedCornersCharuco [ARG Mat image=, ARG Mat charucoCorners=, ARG Mat charucoIds=Mat(), ARG Scalar cornerColor=Scalar(255, 0, 0)]>
java: void drawDetectedCornersCharuco(Mat image, Mat charucoCorners, Mat charucoIds, Scalar cornerColor)
java: void drawDetectedCornersCharuco(Mat image, Mat charucoCorners)
FUNC <void cv.aruco..drawDetectedDiamonds [ARG Mat image=, ARG vector_Mat diamondCorners=, ARG Mat diamondIds=Mat(), ARG Scalar borderColor=Scalar(0, 0, 255)]>
java: void drawDetectedDiamonds(Mat image, List<Mat> diamondCorners, Mat diamondIds, Scalar borderColor)
java: void drawDetectedDiamonds(Mat image, List<Mat> diamondCorners)
FUNC <void cv.aruco..drawDetectedMarkers [ARG Mat image=, ARG vector_Mat corners=, ARG Mat ids=Mat(), ARG Scalar borderColor=Scalar(0, 255, 0)]>
java: void drawDetectedMarkers(Mat image, List<Mat> corners, Mat ids, Scalar borderColor)
java: void drawDetectedMarkers(Mat image, List<Mat> corners)
FUNC <void cv.aruco..drawMarker [ARG Ptr_Dictionary dictionary=, ARG int id=, ARG int sidePixels=, ARG Mat img=, ARG int borderBits=1]>
java: void drawMarker(Dictionary dictionary, int id, int sidePixels, Mat img, int borderBits)
java: void drawMarker(Dictionary dictionary, int id, int sidePixels, Mat img)
FUNC <void cv.aruco..drawPlanarBoard [ARG Ptr_Board board=, ARG Size outSize=, ARG Mat img=, ARG int marginSize=0, ARG int borderBits=1]>
java: void drawPlanarBoard(Board board, Size outSize, Mat img, int marginSize, int borderBits)
java: void drawPlanarBoard(Board board, Size outSize, Mat img)
FUNC <void cv.aruco..estimatePoseSingleMarkers [ARG vector_Mat corners=, ARG float markerLength=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvecs=, ARG Mat tvecs=, ARG Mat _objPoints=Mat()]>
java: void estimatePoseSingleMarkers(List<Mat> corners, float markerLength, Mat cameraMatrix, Mat distCoeffs, Mat rvecs, Mat tvecs, Mat _objPoints)
java: void estimatePoseSingleMarkers(List<Mat> corners, float markerLength, Mat cameraMatrix, Mat distCoeffs, Mat rvecs, Mat tvecs)
FUNC <void cv.aruco..getBoardObjectAndImagePoints [ARG Ptr_Board board=, ARG vector_Mat detectedCorners=, ARG Mat detectedIds=, ARG Mat objPoints=, ARG Mat imgPoints=]>
java: void getBoardObjectAndImagePoints(Board board, List<Mat> detectedCorners, Mat detectedIds, Mat objPoints, Mat imgPoints)
FUNC <void cv.aruco..refineDetectedMarkers [ARG Mat image=, ARG Ptr_Board board=, ARG vector_Mat detectedCorners=, ARG Mat detectedIds=, ARG vector_Mat rejectedCorners=, ARG Mat cameraMatrix=Mat(), ARG Mat distCoeffs=Mat(), ARG float minRepDistance=10.f, ARG float errorCorrectionRate=3.f, ARG bool checkAllOrders=true, ARG Mat recoveredIdxs=Mat(), ARG Ptr_DetectorParameters parameters=DetectorParameters::create()]>
java: void refineDetectedMarkers(Mat image, Board board, List<Mat> detectedCorners, Mat detectedIds, List<Mat> rejectedCorners, Mat cameraMatrix, Mat distCoeffs, float minRepDistance, float errorCorrectionRate, boolean checkAllOrders, Mat recoveredIdxs, DetectorParameters parameters)
java: void refineDetectedMarkers(Mat image, Board board, List<Mat> detectedCorners, Mat detectedIds, List<Mat> rejectedCorners)
